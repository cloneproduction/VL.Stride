[Category("Filter")]
[Category("Filter")]
[WantsMips("Texture0")]

shader MotorSawEdge_TextureFX : FilterBase
{
    //#define xoffset 0.866025
    //#define yoffset -0.5

	[Default(1.0f)]
    compose ComputeFloat2 Radius;

    [Default(1.0f)]
    compose ComputeFloat Power;

    compose ComputeFloat Blur;


    float4 Filter(float4 tex0col)
    {
        float2 uv = streams.TexCoord;
        float2 pixeloffset = Radius.Compute() / ViewSize;

        float2 OffsetXY = pixeloffset / ViewSize;

        float smooth = Lod(ViewSize) * Blur.Compute();

        float4 col = Texture0.SampleLevel(LinearSampler, float2(uv.x, uv.y), smooth) * 5;

        col -= Texture0.SampleLevel(LinearSampler, float2(uv.x - pixeloffset.x, uv.y - pixeloffset.y), 0);
        col -= Texture0.SampleLevel(LinearSampler, float2(uv.x + OffsetXY.x, uv.y + OffsetXY.y), smooth); //bottomright
        col -= Texture0.SampleLevel(LinearSampler, float2(uv.x + OffsetXY.x, uv.y + OffsetXY.y), smooth); //bottomright
        col -= Texture0.SampleLevel(LinearSampler, float2(uv.x + OffsetXY.x, uv.y - OffsetXY.y), smooth); //topright
        col -= Texture0.SampleLevel(LinearSampler, float2(uv.x - OffsetXY.x, uv.y - OffsetXY.y), smooth); //topleft

        col *= 6.0 * - Power.Compute();
        col.a = tex0col.a;
        return col;

        //float edge = IsEdge(streams.TexCoord);
        //return threshold(threshold1, threshold2, edge ) * tex0col* power;
    }

    //float threshold(in float thr1, in float thr2 , in float val) 
    //{
    //     if (val < thr1) {return 0.0;}
    //     if (val > thr2) {return 1.0;}
    //     return val;
    //}

    //// averaged pixel intensity from 3 color channels
    //float avg_intensity(in float4 pix) 
    //{
    //    return (pix.r + pix.g + pix.b)/3.;
    //}

    //float4 get_pixel(in float2 coords, in float dx, in float dy) 
    //{
    //    return Texture0.SampleLevel(LinearSampler, coords + float2(dx, dy), 0);
    //}

    //float IsEdge(in float2 coords)
    //{
    //    float dxtex = 1.0 / 512.0 /*image width*/;
    //    float dytex = 1.0 / 512.0 /*image height*/;
    //    float pix[9];
    //    int k = -1;
    //    float delta;

    //  // read neighboring pixel intensities
    //    for (int i = -1; i < 2; i++)
    //    {
    //        for(int j = -1; j < 2; j++) 
    //        {
    //            k++;
    //            pix[k] = avg_intensity(get_pixel(coords,float(i)*dxtex, float(j)*dytex));
    //        }
    //    }

    //  // average color differences around neighboring pixels
    //  return (abs(pix[1]-pix[7]) + abs(pix[5]-pix[3]) + abs(pix[0]-pix[8])+ abs(pix[2]-pix[6]) )/4.;

      
    //}

};